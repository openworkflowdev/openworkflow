---
title: Workers
description: Long-running processes that execute your workflows
---

A worker is a background process that executes your workflows. It polls the
database for new workflow runs, picks them up, and executes them step by step.
When it finishes one run, it looks for the next one.

Workers are stateless â€” all workflow progress is stored in the database, not
in the worker itself. This means you can stop a worker, restart it, or replace
it with a new one at any time. If a worker crashes, another worker can
seamlessly continue any in-progress workflows from the last completed step.

## Starting a Worker

The recommended way to run a worker is via the CLI:

<CodeGroup>
```bash npm
npx @openworkflow/cli worker start
```

```bash pnpm
pnpx @openworkflow/cli worker start
```

```bash bun
bunx @openworkflow/cli worker start
```

</CodeGroup>

This command:

1. Loads your `openworkflow.config.ts` configuration
2. Discovers workflow files in the configured directories
3. Starts polling the database for work
4. Handles graceful shutdown on SIGINT/SIGTERM

## How Workers Execute Workflows

When a worker picks up a workflow:

1. **Claim**: The worker atomically claims the workflow run from the database
2. **Load history**: The worker loads all completed step attempts
3. **Replay**: The worker executes the workflow function from the beginning
4. **Memoization**: Completed steps return cached results instantly
5. **Execute**: New steps are executed and their results are stored
6. **Complete**: The workflow status is updated to `completed` or `failed`

## Worker Concurrency

Workers can process multiple workflow runs simultaneously. Configure concurrency
in your `openworkflow.config.ts`:

```ts
import { backend } from "./openworkflow/client";
import { defineConfig } from "@openworkflow/cli";

export default defineConfig({
  backend,
  worker: {
    concurrency: 10, // Process up to 10 workflows at once
  },
});
```

Or via the CLI:

<CodeGroup>
```bash npm
npx @openworkflow/cli worker start --concurrency 10
```

```bash pnpm
pnpx @openworkflow/cli worker start --concurrency 10
```

```bash bun
bunx @openworkflow/cli worker start --concurrency 10
```

</CodeGroup>

<Note>
  Start with `concurrency: 10` and tune based on your workload and database
  capacity.
</Note>

## Workflow Concurrency

Workflow specs can also define concurrency buckets that are enforced at claim
time:

```ts
defineWorkflow(
  {
    name: "process-order",
    concurrency: {
      key: ({ input }) => `tenant:${input.tenantId}`, // or: "tenant:acme"
      limit: ({ input }) => input.maxConcurrentOrders, // or: 5
    },
  },
  async ({ step }) => {
    // ...
  },
);
```

Workers will only claim a run when the bucket has capacity. Bucket scope is:

- namespace
- workflow name
- workflow version
- resolved concurrency key

Only active leased `running` runs consume workflow-concurrency slots.
Resolved keys are stored verbatim; only empty/all-whitespace keys are rejected.
Sleeping runs are non-consuming until they are claimed again as actively leased
`running` runs.
Within active `pending` and actively leased `running` runs for the same
workflow+version+key bucket, the resolved `limit` must remain consistent.

## Heartbeats and Crash Recovery

Workers maintain their claim on workflow runs through a heartbeat mechanism:

1. When a worker claims a workflow, it sets an `availableAt` timestamp in the
   future
2. While executing, the worker periodically extends this timestamp
3. If the worker crashes, the heartbeat stops
4. The `availableAt` timestamp expires
5. Another worker can claim and resume the workflow

This ensures workflows are never stuck if a worker crashes.

## High Availability

For production, run multiple worker instances:

<CodeGroup>
```bash npm
# Terminal 1
npx @openworkflow/cli worker start --concurrency 10
# Terminal 2
npx @openworkflow/cli worker start --concurrency 10
```

```bash pnpm
# Terminal 1
pnpx @openworkflow/cli worker start --concurrency 10
# Terminal 2
pnpx @openworkflow/cli worker start --concurrency 10
```

```bash bun
# Terminal 1
bunx @openworkflow/cli worker start --concurrency 10
# Terminal 2
bunx @openworkflow/cli worker start --concurrency 10
```

</CodeGroup>

Workers coordinate through the database:

- Each workflow run is claimed by exactly one worker at a time
- Workers use atomic database operations to prevent duplicate processing
- If a worker crashes, its workflows become available to other workers
- SQLite relies on transaction-level single-writer locking (`BEGIN IMMEDIATE`)
  while Postgres uses row locks plus advisory locks for constrained buckets

## Graceful Shutdown

When a worker receives SIGINT or SIGTERM:

1. It stops polling for new work
2. It waits for active workflow runs to complete their current step
3. Active workflows are persisted back to the database
4. The worker process exits

This ensures no work is lost during deploys.

<CodeGroup>
```bash npm
# The worker handles Ctrl+C gracefully
npx @openworkflow/cli worker start
^C
# [info] Shutting down worker...
# [info] Waiting for active workflows to complete...
# [info] Worker stopped
```

```bash pnpm
# The worker handles Ctrl+C gracefully
pnpx @openworkflow/cli worker start
^C
# [info] Shutting down worker...
# [info] Waiting for active workflows to complete...
# [info] Worker stopped
```

```bash bun
# The worker handles Ctrl+C gracefully
bunx @openworkflow/cli worker start
^C
# [info] Shutting down worker...
# [info] Waiting for active workflows to complete...
# [info] Worker stopped
```

</CodeGroup>

## Workflow Discovery

The CLI automatically discovers workflows from directories specified in your
config:

```ts
// openworkflow.config.ts
export default defineConfig({
  backend,
  dirs: ["./openworkflow"], // Default directory
});
```

Workflow files should export workflows created with `defineWorkflow()`:

```ts
// openworkflow/send-email.ts
import { defineWorkflow } from "openworkflow";

export const sendEmail = defineWorkflow(
  { name: "send-email" },
  async ({ input, step }) => {
    // ...
  },
);
```

The CLI scans for `.ts`, `.js`, `.mts`, `.mjs`, `.cts`, and `.cjs` files.
