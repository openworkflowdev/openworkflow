---
title: Retries
description: Automatic retry behavior for failed steps and workflows
---

In any application, things fail sometimes - a third-party API returns a
500 error, a database connection times out, or a network blip drops a request.
These are transient failures: they go away on their own if you try again.

OpenWorkflow handles this automatically. When a step throws an error, the
workflow is rescheduled with an exponential backoff (increasing delays between
retries). Previously completed steps aren't re-run - only the failed step is
retried.

## How Retries Work

When a step throws an error:

1. The step attempt is marked as `failed`
2. The error is recorded in the database
3. The workflow is rescheduled with exponential backoff
4. When the workflow resumes, it replays to the failed step
5. The step function executes again (not the cached result)

## Automatic Retries in Steps

Steps that throw are automatically retried:

```ts
await step.run({ name: "call-api" }, async () => {
  const response = await fetch("https://api.example.com/data");

  if (!response.ok) {
    // Throwing here triggers a retry
    throw new Error(`API error: ${response.status}`);
  }

  return await response.json();
});
```

Each retry:

- Replays the workflow from the beginning
- Returns cached results for completed steps
- Re-executes the failed step

## Exponential Backoff

Failed workflows are rescheduled with increasing delays:

| Attempt | Delay     |
| ------- | --------- |
| 1       | Immediate |
| 2       | ~1s       |
| 3       | ~2s       |
| 4       | ~4s       |
| 5       | ~8s       |
| ...     | ...       |

This prevents overwhelming external services during outages.

By default, retries continue until canceled or until `deadlineAt` is reached (or
the next retry would pass it). If `maximumAttempts` is configured, the workflow
is also marked `failed` once that limit is reached.

## Retry Policy

Retry behavior is configured per workflow using `retryPolicy` in the workflow
spec:

```ts
import { defineWorkflow } from "openworkflow";

export const chargeCustomer = defineWorkflow(
  {
    name: "charge-customer",
    retryPolicy: {
      initialInterval: "1s",
      backoffCoefficient: 2,
      maximumInterval: "100s",
      maximumAttempts: Infinity,
    },
  },
  async ({ step }) => {
    // workflow implementation
  },
);
```

`retryPolicy` is optional. Any omitted fields use defaults.

| Field                | Description                                           |
| -------------------- | ----------------------------------------------------- |
| `initialInterval`    | Delay before the first retry after a failed attempt   |
| `backoffCoefficient` | Multiplier applied to each subsequent retry delay     |
| `maximumInterval`    | Upper bound for retry delay                           |
| `maximumAttempts`    | Maximum total attempts, including the initial attempt |

## What Triggers a Retry

Retries happen when:

- A step function throws an exception
- A step function returns a rejected promise
- The worker crashes during step execution

Retries do **not** happen for:

- Completed steps (they return cached results)
- Explicitly canceled workflows
- Workflows that complete successfully

## Error Handling

You can catch and handle errors within your workflow:

```ts
defineWorkflow({ name: "with-error-handling" }, async ({ input, step }) => {
  try {
    await step.run({ name: "risky-operation" }, async () => {
      await externalApi.call();
    });
  } catch (error) {
    // Log the error and continue with fallback
    console.error("API call failed:", error);

    await step.run({ name: "fallback-operation" }, async () => {
      await fallbackApi.call();
    });
  }
});
```

<Note>
  When you catch an error, the workflow continues normally. The step is still
  marked as failed in the database, but the workflow doesn't retry from that
  point.
</Note>

## Permanent Failures

A workflow is marked as `failed` permanently when it can no longer be retried
(for example, because `deadlineAt` is reached, the next retry would exceed that
deadline, or `maximumAttempts` has been reached):

- The error is stored in the workflow run record
- No more automatic retries occur
- You can view failed workflows in the dashboard
- Failed workflows can be manually retried or investigated

## Transient vs. Permanent Errors

Design your steps to distinguish between transient and permanent errors:

```ts
await step.run({ name: "call-api" }, async () => {
  const response = await fetch("https://api.example.com/data");

  if (response.status === 503) {
    // Transient - throw to trigger retry
    throw new Error("Service temporarily unavailable");
  }

  if (response.status === 400) {
    // Permanent - bad request won't succeed on retry
    // Handle differently (return error result, cancel workflow, etc.)
    return { success: false, error: "Invalid request" };
  }

  return await response.json();
});
```

## Best Practices

### Use Meaningful Error Messages

Include context in errors for debugging:

```ts
await step.run({ name: "fetch-user" }, async () => {
  const user = await db.users.findOne({ id: input.userId });

  if (!user) {
    throw new Error(`User not found: ${input.userId}`);
  }

  return user;
});
```

## Monitoring Retries

Use the dashboard to monitor workflow health:

- View failed workflow runs
- Inspect step attempt errors
- See retry history for a workflow
- Identify patterns in failures

<CodeGroup>
```bash npm
npx @openworkflow/cli dashboard
```

```bash pnpm
pnpx @openworkflow/cli dashboard
```

```bash bun
bunx @openworkflow/cli dashboard
```

</CodeGroup>
