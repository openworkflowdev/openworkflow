---
title: Retries
description: Automatic retry behavior for failed steps and workflows
---

In any application, things fail sometimes - a third-party API returns a
500 error, a database connection times out, or a network blip drops a request.
These are transient failures: they go away on their own if you try again.

OpenWorkflow handles this automatically. When a step throws an error, the
workflow is rescheduled with an exponential backoff (increasing delays between
retries). Previously completed steps aren't re-run - only the failed step is
retried.

## How Retries Work

When a step throws an error:

1. The step attempt is marked as `failed`
2. The error is recorded in the database
3. The workflow is rescheduled with exponential backoff
4. When the workflow resumes, it replays to the failed step
5. The step function executes again (not the cached result)

## Automatic Retries in Steps

Steps that throw are automatically retried:

```ts
await step.run({ name: "call-api" }, async () => {
  const response = await fetch("https://api.example.com/data");

  if (!response.ok) {
    // Throwing here triggers a retry
    throw new Error(`API error: ${response.status}`);
  }

  return await response.json();
});
```

Each retry:

- Replays the workflow from the beginning
- Returns cached results for completed steps
- Re-executes the failed step

## Retry Policy

Both steps and workflows use the same retry policy shape. A retry policy
controls exponential backoff — how long to wait between retries, how fast delays
grow, and when to stop retrying.

With the defaults, retry delays look like this:

| Attempt | Delay     |
| ------- | --------- |
| 1       | Immediate |
| 2       | ~1s       |
| 3       | ~2s       |
| 4       | ~4s       |
| 5       | ~8s       |
| ...     | ...       |

This prevents overwhelming external services during outages. Retries continue
until canceled, until `deadlineAt` is reached (or the next retry would pass it),
or until `maximumAttempts` is exhausted.

Retry policies have the following fields:

| Field                | Default    | Description                                         |
| -------------------- | ---------- | --------------------------------------------------- |
| `initialInterval`    | `"1s"`     | Delay before the first retry after a failed attempt |
| `backoffCoefficient` | `2`        | Multiplier applied to each subsequent retry delay   |
| `maximumInterval`    | `"100s"`   | Upper bound for retry delay                         |
| `maximumAttempts`    | `Infinity` | Maximum attempts, including the initial one         |

### Step Retry Policy

Each `step.run(...)` can define its own retry policy. If you omit `retryPolicy`,
OpenWorkflow uses the defaults shown above.

```ts
await step.run(
  {
    name: "call-api",
    retryPolicy: {
      initialInterval: "500ms",
      backoffCoefficient: 2,
      maximumInterval: "30s",
      maximumAttempts: 5,
    },
  },
  async () => {
    // step logic
  },
);
```

### Workflow Retry Policy

Workflow-level `retryPolicy` applies to non-step failures — for example, missing
workflow definitions or errors thrown outside `step.run`. If you omit
`retryPolicy` (or individual fields), OpenWorkflow uses the same defaults.

```ts
import { defineWorkflow } from "openworkflow";

defineWorkflow(
  {
    name: "charge-customer",
    retryPolicy: {
      initialInterval: "500ms",
      backoffCoefficient: 2,
      maximumInterval: "30s",
      maximumAttempts: 5,
    },
  },
  async ({ step }) => {
    // workflow implementation
  },
);
```

## What Triggers a Retry

Retries happen when:

- A step function throws an exception
- A step function returns a rejected promise
- The worker crashes during step execution

Retries do **not** happen for:

- Completed steps (they return cached results)
- Explicitly canceled workflows
- Workflows that complete successfully

## Error Handling

You can catch and handle errors within your workflow:

```ts
defineWorkflow({ name: "with-error-handling" }, async ({ input, step }) => {
  try {
    await step.run({ name: "risky-operation" }, async () => {
      await externalApi.call();
    });
  } catch (error) {
    // Log the error and continue with fallback
    console.error("API call failed:", error);

    await step.run({ name: "fallback-operation" }, async () => {
      await fallbackApi.call();
    });
  }
});
```

<Note>
  When you catch an error, the workflow continues normally. The step is still
  marked as failed in the database, but the workflow doesn't retry from that
  point.
</Note>

## Permanent Failures

A workflow is marked as `failed` permanently when it can no longer be retried
(for example, because `deadlineAt` is reached, the next retry would exceed that
deadline, or `maximumAttempts` has been reached):

- The error is stored in the workflow run record
- No more automatic retries occur
- You can view failed workflows in the dashboard
- Failed workflows can be manually retried or investigated

## Transient vs. Permanent Errors

Design your steps to distinguish between transient and permanent errors:

```ts
await step.run({ name: "call-api" }, async () => {
  const response = await fetch("https://api.example.com/data");

  if (response.status === 503) {
    // Transient - throw to trigger retry
    throw new Error("Service temporarily unavailable");
  }

  if (response.status === 400) {
    // Permanent - bad request won't succeed on retry
    // Handle differently (return error result, cancel workflow, etc.)
    return { success: false, error: "Invalid request" };
  }

  return await response.json();
});
```

## Best Practices

### Use Meaningful Error Messages

Include context in errors for debugging:

```ts
await step.run({ name: "fetch-user" }, async () => {
  const user = await db.users.findOne({ id: input.userId });

  if (!user) {
    throw new Error(`User not found: ${input.userId}`);
  }

  return user;
});
```

## Monitoring Retries

Use the dashboard to monitor workflow health:

- View failed workflow runs
- Inspect step attempt errors
- See retry history for a workflow
- Identify patterns in failures

<CodeGroup>
```bash npm
npx @openworkflow/cli dashboard
```

```bash pnpm
pnpx @openworkflow/cli dashboard
```

```bash bun
bunx @openworkflow/cli dashboard
```

</CodeGroup>
